## Node JS

> node Js란? Chrome V8 Javascript 엔진으로 빌드된 javascript 런타임입니다.

노드는 자바스크립트 런타임입니다. 렅나임은 특정 언어로 만든 프로그램을 실행할 수 있는 환경을 듯합니다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있습니다.


### 노드의 내부 구조


노드는 V8과 더불어 **libuv**라는 라이브러를 사용합니다. V8과 libuv는 C와 C++로 구현 되어있습니다. libuv 라이브러리는 노드의 특성인 **이벤트 기반, 논 블로킹 I/O 모델**을 구현하고 있습니다.이 모델이 무엇이고 어떤 장단점이 있는지 알아봅시다.
<img src="https://github.com/hindong/node_JS_lecture/blob/main/chapter01/pic1.png"/>

### 이벤트 기반
이벤트 기반이란 이벤트가 발생할 떄 미리 지정해둔 작업을 수행하는 방식을 의미합니다. 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있습니다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 합니다.
이를 이벤트 리스너에 콜백 함수를 등록한다고 표현합니다.
버튼을 클릭할 떄 경고창을 띄우도록 설정하는 것을 예로 들면, 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록하면 클릭 이벤트가 발생할 때마다 콜백 함수가 실행되어 경고차이 뜨는 것 입니다.

노드도 이벤트 기반 방식으로 동작하므로, 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출하고 발생한 이벤트가 없거나 발생했던 이벤트를 모두 처리하면, 노드는 다음 이벤트가 발생할 떄 까지 대기합니다.

이벤트 기반 모델에서는 **이벤트 루프**라는 개념이 등장합니다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.

노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견했다면 호출한 함수를 호출 스택에 넣습니다.

```Javascript
function first(){
    second();
    console.log("first");
}

function second(){
    third();
    console.log("second");
}

function third(){
    console.log("third");
}

first();
```

위 코드에서 실행 순서는 first() 함수가 제일 먼저 호출되고, 그 안의 second()함수가 호출된 뒤에 마지막으로 third() 함수가 호출됩니다.

출력 결과는

```
third
second
first
```

입니다. 이 떄 함수 콜스택에 쌓이는 순서는

third()
second()
first()
anonymous

의 형식으로 쌓이게 됩니다. 이 때 anonymous 함수는 처음 실행 시의 전역 컨텍스트를 의미합니다.
전역 컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미합니다. 자바스크립트 코드는 실행 시 기본적으로 전역 컨텍스트 안에서 돌아간다고 생각하는 게 좋습니다. 위 3개의 함수가 모두 완료된다면 anonymous 까지 지워지고 anonymous까지 지워졌다면 호출 스택은 비어 있게 됩니다.

이번에는 특정 시간 이후에 코드를 실행하는 setTimeoust을 사용해보겠습니다.
```javascript
function run(){
    console.log("3초 후 실행");
}

console.log("start");
setTimeout(run, 3000);
console.log("end");
```

위 코드는 자바스크립트 비동기 공부를 처음 시작할 때 단골로 나오는 패턴입니다.
```
start
end
3초 후 실행
```

의 순서대로 나오게 됩니다. 위 순서를 이해하기 위해서 *이벤트 루프, 태스크 큐, 백그라운드*를 알아야 합니다.

+ 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다.노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 부릅니다.
+ 백그라운드: setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳입니다. 자바스크립트가 아닌 다른언어로 작성된 프로그램이라고 생각해도 무방합니다. 여러 작업이 동시에 실행될 수 있습니다.(기본적으로 자바스크립트는 싱글 스레드 언어입니다.)
+ 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냅니다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부릅니다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 합니다.

함수들이 실행되면서 호출 스택에 쌓이게 되는데 이 때 setTimeout 실행시 콜백함수는 백그라운드로 보내집니다. 백그라운드에서 setTimeout 시간이 지난후 태스크 큐로 보내집니다.이 때 바로 호출 스택에 쌓이는 것이 아닌 호출 스택이 비워지면 이벤트 루프가 태스크 큐의 콜백을 호출 스택으로 올립니다.
만약 호출 스택에 함수들이 너무 많다던지 오래 걸리는 연산을 수행하고 있을 경우 위 setTimeout에 넘겨줬던 시간이 지난 후에도 콜백함수가 실행되지 않을수도 있습니다. 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 함수를 호출 스택으로 가져오니까요. 이 때문에 setTimeout의 시간이 정확하지 않을 수도 있습니다.


### 논 블로킹 I/O
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있습니다. 작업에는 두 가지 종류가 있는데, 동시에
실행될 수 있는 작업과 동시에 실행될 수 없는 작업입니다. 기본적으로 자바스크립트는 싱글 쓰레드 언어이기 때문에 일반적으로 자바스크립트 코드는 동시에 실행될 수 없습니다. I/O는 입출력을 의미합니다. *파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)*이나 네트워크를 통한 요청 같은 작업이 I/O의 일종입니다. 이러한 작업을 할  떄 노드는 논블로킹 방식으로 처리하는 방법을 제공합니다. *논 블로킹*이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻합니다. 반대로 *블로킹*은 이전 작업이 끝나야만 다음 작업을 수행할 수 있는 것을 의미합니다.

<img src="https://github.com/hindong/node_JS_lecture/blob/main/chapter01/pci2.jpg" width="300" height="300"/>
